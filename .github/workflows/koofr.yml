# å·¥ä½œæµåç§°
name: CI with Persistent Chroot Environment (Backblaze B2)

# å·¥ä½œæµè§¦å‘å™¨ï¼šæ‰‹åŠ¨è§¦å‘ (workflow_dispatch)
on:
  workflow_dispatch:
    inputs:
      use_cache:
        description: 'æ˜¯å¦å¯ç”¨æ¢å¤ç¼“å­˜ (Restore from backup?)'
        required: true
        type: boolean
        default: true
      run_startup_script:
        description: 'æ˜¯å¦è‡ªåŠ¨æ‰§è¡Œå¯åŠ¨è„šæœ¬ (Auto-run startup script?)'
        required: true
        type: boolean
        default: true
      enable_ssh:
        description: 'æ˜¯å¦å¯ç”¨SSHæ‰‹åŠ¨è°ƒè¯• (Enable SSH for manual debug?)'
        required: true
        type: boolean
        default: false
      force_backup:
        description: 'å¼ºåˆ¶å¤‡ä»½? (å³ä½¿å·¥ä½œæµå¤±è´¥æˆ–è¢«å–æ¶ˆä¹Ÿæ‰§è¡Œå¤‡ä»½) (Force backup? Runs even if workflow fails or is cancelled)'
        required: true
        type: boolean
        default: false

# å…¨å±€ç¯å¢ƒå˜é‡
env:
  # --- Chroot & Runtime Config ---
  CHROOT_DIR: /mnt/minisys
  RUN_DURATION_MINUTES: 300

  # --- Backblaze B2 å¤‡ä»½é…ç½® ---
  B2_REMOTE_NAME: b2
  B2_BUCKET_NAME: ${{ secrets.B2_BUCKET_NAME }}
  B2_BACKUP_DIR: backup
  BACKUP_PREFIX: minisys_backup_
  BACKUP_RETENTION_COUNT: 2
  # *** ä¿®æ­£ï¼šä¿®å¤äº† --transfers-8 çš„è¯­æ³•é”™è¯¯ ***
  RCLONE_FLAGS: "--multi-thread-streams 4 --buffer-size 64M --fast-list --transfers 8 --progress"
  B2_ACCOUNT_ID: ${{ secrets.B2_ACCOUNT_ID }}
  B2_ACCOUNT_KEY: ${{ secrets.B2_ACCOUNT_KEY }}

  # --- In-Chroot App Secrets (e.g., Loophole) ---
  LOOPHOLE_WEBDAV_USER: ${{ secrets.LOOPHOLE_WEBDAV_USER }}
  LOOPHOLE_WEBDAV_PASS: ${{ secrets.LOOPHOLE_WEBDAV_PASS }}
  LOOPHOLE_WEBDAV_HOSTNAME: ${{ secrets.LOOPHOLE_WEBDAV_HOSTNAME }}
  LOOPHOLE_NAPCAT_HOSTNAME: ${{ secrets.LOOPHOLE_NAPCAT_HOSTNAME }}

# ä½œä¸šå®šä¹‰
jobs:
  build-and-debug:
    # è¿è¡Œç¯å¢ƒ
    runs-on: ubuntu-latest

    # ä½œä¸šæ­¥éª¤
    steps:
      - name: 1. æœ€å¤§åŒ–è¿è¡Œå™¨ç£ç›˜ç©ºé—´ (Maximize runner disk space)
        run: |
          echo "æ¸…ç†å‰ï¼Œåˆå§‹ç£ç›˜ç©ºé—´ï¼š"
          df -h /
          echo "å¼€å§‹æ¸…ç†é¢„è£…è½¯ä»¶ä»¥é‡Šæ”¾ç©ºé—´..."
          sudo rm -rf /usr/share/dotnet /opt/ghc /usr/local/share/boost "$AGENT_TOOLSDIRECTORY"
          echo "âœ… æ¸…ç†å®Œæˆï¼Œå½“å‰å¯ç”¨ç©ºé—´ï¼š"
          df -h /

      - name: 2. å®‰è£…æ‰€éœ€ä¾èµ– (Install dependencies)
        run: |
          echo "æ­£åœ¨å®‰è£… debootstrap, rclone, pigz..."
          sudo apt-get update
          sudo apt-get install -y debootstrap rclone pigz
          echo "âœ… ä¾èµ–å®‰è£…å®Œæ¯•ã€‚"

      - name: 3. æ¢å¤å¤‡ä»½æˆ–åˆ›å»ºæ–°ç³»ç»Ÿ (Restore backup or create new system)
        id: restore_or_create
        run: |
          sudo mkdir -p ${{ env.CHROOT_DIR }}
          if [[ "${{ github.event.inputs.use_cache }}" == "true" ]]; then
            echo "ğŸ” ç”¨æˆ·é€‰æ‹©å¯ç”¨ç¼“å­˜ã€‚æ­£åœ¨é…ç½® rclone (B2) å¹¶æ£€æŸ¥å¤‡ä»½..."
            rclone config create ${{ env.B2_REMOTE_NAME }} b2 account "${{ env.B2_ACCOUNT_ID }}" key "${{ env.B2_ACCOUNT_KEY }}"
            
            REMOTE_BASE_PATH="${{ env.B2_REMOTE_NAME }}:${{ env.B2_BUCKET_NAME }}/${{ env.B2_BACKUP_DIR }}"
            # æœç´¢æ—¶åŒ…å«*ä»¥åŒ¹é…æ–‡ä»¶å’Œç›®å½•
            echo "æ­£åœ¨æŸ¥æ‰¾æœ€æ–°çš„å¤‡ä»½æ¡ç›® (åŒ…æ‹¬æ–‡ä»¶å’Œç›®å½•)..."
            LATEST_ENTRY=$(rclone lsf ${REMOTE_BASE_PATH} --include "${{ env.BACKUP_PREFIX }}*" | sort -r | head -n 1)
            
            if [ -n "$LATEST_ENTRY" ]; then
              ACTUAL_BACKUP_PATH=""
              BACKUP_DISPLAY_NAME=""

              if [[ "$LATEST_ENTRY" == */ ]]; then
                echo "â„¹ï¸ å‘ç°æ—§ç‰ˆç›®å½•æ ¼å¼å¤‡ä»½: ${LATEST_ENTRY}ã€‚æ­£åœ¨æ¢æµ‹å…¶å†…éƒ¨çš„å®é™…å¤‡ä»½æ–‡ä»¶..."
                ACTUAL_FILENAME=$(rclone lsf "${REMOTE_BASE_PATH}/${LATEST_ENTRY}" | head -n 1)
                if [ -z "$ACTUAL_FILENAME" ]; then
                  echo "âŒ æ¢å¤å¤±è´¥ï¼šå¤‡ä»½ç›®å½• '${LATEST_ENTRY}' ä¸ºç©ºï¼å°†åˆ é™¤æ­¤ç©ºç›®å½•å¹¶åˆ›å»ºæ–°ç³»ç»Ÿã€‚"
                  rclone purge "${REMOTE_BASE_PATH}/${LATEST_ENTRY}"
                  LATEST_ENTRY="" 
                else
                  ACTUAL_BACKUP_PATH="${REMOTE_BASE_PATH}/${LATEST_ENTRY}${ACTUAL_FILENAME}"
                  BACKUP_DISPLAY_NAME="${LATEST_ENTRY}${ACTUAL_FILENAME}"
                  echo "âœ… æˆåŠŸå®šä½åˆ°å®é™…å¤‡ä»½æ–‡ä»¶: ${ACTUAL_FILENAME}"
                fi
              else
                echo "â„¹ï¸ å‘ç°æ ‡å‡†æ–‡ä»¶æ ¼å¼å¤‡ä»½: ${LATEST_ENTRY}ã€‚"
                ACTUAL_BACKUP_PATH="${REMOTE_BASE_PATH}/${LATEST_ENTRY}"
                BACKUP_DISPLAY_NAME="$LATEST_ENTRY"
              fi

              if [ -n "$LATEST_ENTRY" ]; then
                LOCAL_RESTORE_FILE="/tmp/restore_backup.download"
                echo "âœ… å‡†å¤‡æ¢å¤å¤‡ä»½ã€‚æ­£åœ¨å°† '${BACKUP_DISPLAY_NAME}' å®Œæ•´ä¸‹è½½åˆ°æœ¬åœ°..."
                rclone copyto "${ACTUAL_BACKUP_PATH}" ${LOCAL_RESTORE_FILE} ${{ env.RCLONE_FLAGS }}

                if [ ! -s "${LOCAL_RESTORE_FILE}" ]; then
                  echo "âŒ æ¢å¤å¤±è´¥ï¼šä¸‹è½½çš„å¤‡ä»½æ–‡ä»¶ä¸ºç©ºæˆ–ä¸‹è½½å¤±è´¥ï¼å¯èƒ½æ˜¯è¿œç¨‹æ–‡ä»¶å·²æŸåã€‚"
                  LATEST_ENTRY=""
                else
                  echo "âœ… ä¸‹è½½å®Œæˆã€‚æ­£åœ¨ä»æœ¬åœ°æ–‡ä»¶è§£å‹ï¼ˆå…¼å®¹.tarå’Œ.tar.gzï¼‰..."
                  cat ${LOCAL_RESTORE_FILE} | { pigz -dc || cat; } | sudo tar -xpf - -C ${{ env.CHROOT_DIR }}
                  rm -f ${LOCAL_RESTORE_FILE}
                  
                  if [ ! -d "${{ env.CHROOT_DIR }}/proc" ] && [ ! -d "${{ env.CHROOT_DIR }}/bin" ]; then
                    echo "âŒ æ¢å¤æ ¡éªŒå¤±è´¥ï¼å¤‡ä»½æ–‡ä»¶ '$BACKUP_DISPLAY_NAME' å¯èƒ½å·²æŸåã€‚"
                    echo "  -> æ­£åœ¨ä» B2 åˆ é™¤æŸåçš„å¤‡ä»½..."
                    if [[ "$LATEST_ENTRY" == */ ]]; then rclone purge "${REMOTE_BASE_PATH}/${LATEST_ENTRY}"; else rclone deletefile "${ACTUAL_BACKUP_PATH}"; fi
                    echo "  -> è‡ªåŠ¨è½¬ä¸ºåˆ›å»ºæ–°ç³»ç»Ÿ..."
                    sudo rm -rf ${{ env.CHROOT_DIR }}/*
                    sudo debootstrap --variant=minbase jammy ${{ env.CHROOT_DIR }} http://archive.ubuntu.com/ubuntu/
                    echo "restored=false" >> $GITHUB_OUTPUT
                  else
                    echo "âœ… æ¢å¤æ ¡éªŒæˆåŠŸï¼Œç³»ç»Ÿå®Œæ•´ã€‚"
                    echo "restored=true" >> $GITHUB_OUTPUT
                  fi
                fi
              fi
            fi

            if [ -z "$LATEST_ENTRY" ]; then
              echo "âš ï¸ æœªèƒ½æˆåŠŸæ¢å¤å¤‡ä»½ã€‚å°†è‡ªåŠ¨åˆ›å»ºå…¨æ–°ç³»ç»Ÿ..."
              sudo debootstrap --variant=minbase jammy ${{ env.CHROOT_DIR }} http://archive.ubuntu.com/ubuntu/
              echo "restored=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "â„¹ï¸ ç”¨æˆ·é€‰æ‹©ä¸ä½¿ç”¨ç¼“å­˜ã€‚å°†åˆ›å»ºå…¨æ–°ç³»ç»Ÿ..."
            sudo debootstrap --variant=minbase jammy ${{ env.CHROOT_DIR }} http://archive.ubuntu.com/ubuntu/
            echo "restored=false" >> $GITHUB_OUTPUT
          fi

      - name: 4. æŒ‚è½½è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿåˆ° Chroot ç¯å¢ƒ (Mount virtual filesystems)
        run: |
          echo "æ­£åœ¨æŒ‚è½½è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ..."
          MNT_DIR=${{ env.CHROOT_DIR }}
          sudo mount -t proc proc "${MNT_DIR}/proc"
          sudo mount -o bind /dev "${MNT_DIR}/dev"
          sudo mount -o bind /dev/pts "${MNT_DIR}/dev/pts"
          sudo mount -o bind /sys "${MNT_DIR}/sys"
          echo "âœ… è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿå·²æŒ‚è½½ã€‚"

      - name: 5. æ¸…ç† Chroot ç¯å¢ƒç©ºé—´ (Clean chroot environment)
        if: steps.restore_or_create.outputs.restored == 'true'
        run: |
          echo "ğŸ§¹ å¼€å§‹æ¸…ç† chroot ç¯å¢ƒå†…çš„ç¼“å­˜å’Œä¸´æ—¶æ–‡ä»¶..."
          sudo chroot ${{ env.CHROOT_DIR }} /bin/bash -c " \
            echo '  -> æ­£åœ¨æ¸…ç† apt ç¼“å­˜...'; \
            apt-get clean -y > /dev/null 2>&1 || true; \
            rm -rf /var/lib/apt/lists/*; \
            echo '  -> æ­£åœ¨æ¸…ç†ä¸´æ—¶æ–‡ä»¶...'; \
            rm -rf /tmp/* /var/tmp/*; \
            echo '  -> æ­£åœ¨æ¸…ç† /root ç›®å½•ä¸‹çš„ç¼“å­˜...'; \
            rm -rf /root/.cache; \
            echo 'âœ… Chroot ç¯å¢ƒæ¸…ç†å®Œæˆã€‚'"

      - name: 6A. [è‡ªåŠ¨åŒ–è·¯å¾„] å¯åŠ¨æœåŠ¡ (Automated Path - Run Services)
        if: steps.restore_or_create.outputs.restored == 'true' && github.event.inputs.run_startup_script == 'true' && github.event.inputs.enable_ssh == 'false'
        run: |
          echo "ğŸš€ è‡ªåŠ¨åŒ–è·¯å¾„ï¼šå‡†å¤‡åœ¨ chroot ç¯å¢ƒä¸­å¯åŠ¨æœåŠ¡..."
          cat << EOF > ./inject_secrets.sh
          export LOOPHOLE_WEBDAV_USER='${{ env.LOOPHOLE_WEBDAV_USER }}'
          export LOOPHOLE_WEBDAV_PASS='${{ env.LOOPHOLE_WEBDAV_PASS }}'
          export LOOPHOLE_WEBDAV_HOSTNAME='${{ env.LOOPHOLE_WEBDAV_HOSTNAME }}'
          export LOOPHOLE_NAPCAT_HOSTNAME='${{ env.LOOPHOLE_NAPCAT_HOSTNAME }}'
          EOF
          sudo mv ./inject_secrets.sh ${{ env.CHROOT_DIR }}/root/inject_secrets.sh
          sudo chmod +x ${{ env.CHROOT_DIR }}/root/inject_secrets.sh

          sudo chroot ${{ env.CHROOT_DIR }} /bin/bash -c "source /root/inject_secrets.sh && /root/startup.sh" &

          echo "âœ… å¯åŠ¨è„šæœ¬å·²åœ¨åå°æ‰§è¡Œã€‚å·¥ä½œæµå°†æŒç»­è¿è¡Œ ${{ env.RUN_DURATION_MINUTES }} åˆ†é’Ÿ..."
          sleep ${{ env.RUN_DURATION_MINUTES }}m

      - name: 6B. [æ‰‹åŠ¨è°ƒè¯•è·¯å¾„] å¯ç”¨ Upterm SSH ä¼šè¯ (Manual Path - Enable SSH Session)
        if: github.event.inputs.enable_ssh == 'true'
        uses: lhotari/action-upterm@v1
        with:
          limit-access-to-actor: true
          wait-timeout-minutes: ${{ env.RUN_DURATION_MINUTES }}

      - name: 7. å¸è½½ Chroot ç¯å¢ƒçš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ (Unmount virtual filesystems)
        if: always()
        run: |
          echo "ä¼šè¯ç»“æŸã€‚ä¸ºå®‰å…¨å¤‡ä»½ï¼Œæ­£åœ¨å¸è½½æ‰€æœ‰è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ..."
          MNT_DIR=${{ env.CHROOT_DIR }}
          sudo umount -l "${MNT_DIR}/dev/pts" || true
          sudo umount -l "${MNT_DIR}/dev" || true
          sudo umount -l "${MNT_DIR}/proc" || true
          sudo umount -l "${MNT_DIR}/sys" || true
          echo "âœ… è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿå·²å…¨éƒ¨å¸è½½ã€‚"

      - name: 8. å¤‡ä»½ç³»ç»Ÿç¯å¢ƒåˆ° Backblaze B2 (Backup environment to Backblaze B2)
        if: github.event.inputs.force_backup == true || !cancelled()
        run: |
          echo "å¼€å§‹æ‰“åŒ…å¹¶ä¸Šä¼ å¤‡ä»½åˆ° Backblaze B2..."
          if [ ! -d "${{ env.CHROOT_DIR }}/bin" ]; then
            echo "âŒ chrootç¯å¢ƒæ— æ•ˆæˆ–ä¸ºç©ºï¼Œè·³è¿‡å¤‡ä»½ä»¥é˜²ä¸Šä¼ ç©ºæ–‡ä»¶ã€‚"
            exit 0
          fi
          
          echo "æ­£åœ¨åœæ­¢chrootå†…çš„æœåŠ¡ï¼ˆå¦‚pm2ï¼‰ï¼Œä»¥ç¡®ä¿æ•°æ®ä¸€è‡´æ€§..."
          sudo chroot ${{ env.CHROOT_DIR }} bash -c 'command -v pm2 && pm2 stop all' || true
          
          rclone config create ${{ env.B2_REMOTE_NAME }} b2 account "${{ env.B2_ACCOUNT_ID }}" key "${{ env.B2_ACCOUNT_KEY }}"
          
          BACKUP_FILENAME="${{ env.BACKUP_PREFIX }}$(date +%Y%m%d_%H%M%S).tar.gz"
          REMOTE_PATH="${{ env.B2_REMOTE_NAME }}:${{ env.B2_BUCKET_NAME }}/${{ env.B2_BACKUP_DIR }}"
          LOCAL_BACKUP_FILE="/tmp/${BACKUP_FILENAME}"

          echo "âœ… å°†ç»Ÿä¸€ä½¿ç”¨ pigz è¿›è¡Œå¤šçº¿ç¨‹å‹ç¼©..."
          sudo tar -cpf - -C ${{ env.CHROOT_DIR }} . | pigz -c > ${LOCAL_BACKUP_FILE}

          if [ ! -s "${LOCAL_BACKUP_FILE}" ]; then
              echo "âŒ é”™è¯¯ï¼šæœ¬åœ°å¤‡ä»½æ–‡ä»¶åˆ›å»ºå¤±è´¥æˆ–ä¸ºç©ºï¼ä¸­æ­¢å¤‡ä»½ã€‚"
              exit 1
          fi
          echo "âœ… æœ¬åœ°å¤‡ä»½æ–‡ä»¶åˆ›å»ºæˆåŠŸ: ${LOCAL_BACKUP_FILE}"
          
          echo "æ­£åœ¨ä¸Šä¼ å¤‡ä»½æ–‡ä»¶: $BACKUP_FILENAME"
          rclone copyto ${LOCAL_BACKUP_FILE} ${REMOTE_PATH}/${BACKUP_FILENAME} ${{ env.RCLONE_FLAGS }}
          echo "âœ… å¤‡ä»½ä¸Šä¼ æˆåŠŸã€‚"
          sudo rm -f ${LOCAL_BACKUP_FILE}

          echo "æ‰§è¡Œå¤‡ä»½ä¿ç•™ç­–ç•¥ (ä¿ç•™æœ€æ–°çš„ ${{ env.BACKUP_RETENTION_COUNT }} ä¸ª)..."
          REMOTE_FULL_PATH="${REMOTE_PATH}/"
          BACKUPS_TO_DELETE=$(rclone lsf ${REMOTE_FULL_PATH} --include "${{ env.BACKUP_PREFIX }}*" | sort | head -n -${{ env.BACKUP_RETENTION_COUNT }})
          
          if [ -n "$BACKUPS_TO_DELETE" ]; then
            echo "ğŸ—‘ï¸ å‘ç°ä»¥ä¸‹æ—§å¤‡ä»½å°†è¢«æ¸…ç†:"
            echo "$BACKUPS_TO_DELETE"
            for backup_entry in $BACKUPS_TO_DELETE; do
              if [[ "$backup_entry" == */ ]]; then
                echo "  -> æ­£åœ¨åˆ é™¤æ—§ç‰ˆç›®å½•å¤‡ä»½: $backup_entry ..."
                rclone purge "${REMOTE_FULL_PATH}${backup_entry}"
              else
                echo "  -> æ­£åœ¨åˆ é™¤æ—§ç‰ˆæ–‡ä»¶å¤‡ä»½: $backup_entry ..."
                rclone deletefile "${REMOTE_FULL_PATH}${backup_entry}"
              fi
            done
            echo "âœ… æ—§å¤‡ä»½æ¸…ç†å®Œæ¯•ã€‚"
          else
            echo "âœ… æ— éœ€æ¸…ç†æ—§å¤‡ä»½ã€‚"
          fi
          
          echo "âœ… å¤‡ä»½æµç¨‹æ‰§è¡Œå®Œæ¯•ã€‚"