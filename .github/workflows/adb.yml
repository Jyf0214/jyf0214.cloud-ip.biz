# å·¥ä½œæµåç§°
name: CI with Persistent Environment (Windows + WSL + RDP - ZSTD v3)

# å·¥ä½œæµè§¦å‘å™¨
on:
  workflow_dispatch:
    inputs:
      # --- æ ¸å¿ƒæ§åˆ¶å¼€å…³ ---
      create_backup_on_finish: { description: 'âœ… [æ ¸å¿ƒ] æ˜¯å¦åœ¨ç»“æŸæ—¶åˆ›å»ºç¯å¢ƒå¤‡ä»½? (è¿™å°†å½±å“è¿è¡Œæ—¶é•¿)', required: true, type: boolean, default: false }
      run_startup_script: { description: 'ğŸš€ [æ ¸å¿ƒ] æ˜¯å¦è‡ªåŠ¨æ‰§è¡ŒWSLå†…çš„æœåŠ¡å¯åŠ¨è„šæœ¬?', required: true, type: boolean, default: true }
      enable_rdp_access: { description: 'ğŸ¤« [è°ƒè¯•] æ˜¯å¦å¯ç”¨RDPè¿œç¨‹æ¡Œé¢ (å°†æš‚åœè‡ªåŠ¨åŒ–)?', required: true, type: boolean, default: false }

      # --- [æ–°å¢] æœåŠ¡ç‹¬ç«‹å¯åŠ¨å¼€å…³ (ä»…å½“ "run_startup_script" ä¸º true æ—¶ç”Ÿæ•ˆ) ---
      run_launcher: { description: '  - æ˜¯å¦å¯åŠ¨ launcher æœåŠ¡?', type: boolean, default: true }
      run_redis: { description: '  - æ˜¯å¦å¯åŠ¨ Redis æœåŠ¡?', type: boolean, default: true }
      run_yunzai: { description: '  - æ˜¯å¦å¯åŠ¨ Yunzai-Bot æœåŠ¡?', type: boolean, default: true }
      run_loophole_webdav: { description: '  - æ˜¯å¦å¯åŠ¨ Loophole WebDAV éš§é“?', type: boolean, default: true }
      enable_napcat_tunnel: { description: '  - (Loophole) æ˜¯å¦é¢å¤–å¯ç”¨ Napcat å†…ç½‘ç©¿é€?', type: boolean, default: false }
      run_openlist: { description: '  - æ˜¯å¦å¯åŠ¨ openlist æœåŠ¡?', type: boolean, default: true }
      run_chmlfrp: { description: '  - æ˜¯å¦å¯åŠ¨ ChmlFrp æœåŠ¡?', type: boolean, default: true }

  schedule:
    - cron: '30 */6 * * *'

# å¹¶å‘æ§åˆ¶
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

# å…¨å±€ç¯å¢ƒå˜é‡
env:
  # --- WSL å’Œå¤‡ä»½é…ç½® ---
  WSL_DISTRO_NAME: "Ubuntu-Runner"
  WSL_INSTALL_DIR: "C:\\wsl-distro"
  LOCAL_ARCHIVE_PATH: "C:\\temp\\backup.tar"
  LOCAL_COMPRESSED_PATH: "C:\\temp\\backup.tar.zst"
  BACKUP_PREFIX: "minisys_wsl_backup_"
  WEBDAV_REMOTE_PATH: "backup/wsl" # å»ºè®®ä¸ºWSLå¤‡ä»½ä½¿ç”¨ç‹¬ç«‹çš„å­ç›®å½•

  # --- Rclone å’Œé€šç”¨å·¥å…·é…ç½® ---
  RCLONE_FLAGS: "--multi-thread-streams 4 --buffer-size 64M --fast-list --transfers 8 --progress"
  
  # --- Secrets ---
  PAT: ${{ secrets.PAT }}
  LOOPHOLE_WEBDAV_USER: ${{ secrets.LOOPHOLE_WEBDAV_USER }}
  LOOPHOLE_WEBDAV_PASS: ${{ secrets.LOOPHOLE_WEBDAV_PASS }}
  LOOPHOLE_WEBDAV_HOSTNAME: ${{ secrets.LOOPHOLE_WEBDAV_HOSTNAME }}
  LOOPHOLE_NAPCAT_HOSTNAME: ${{ secrets.LOOPHOLE_NAPCAT_HOSTNAME }}
  WEBDAV_URL: ${{ secrets.WEBDAV_URL }}
  WEBDAV_USER: ${{ secrets.WEBDAV_USER }}
  WEBDAV_PASS: ${{ secrets.WEBDAV_PASS }}
  NAPCATUSER: ${{ secrets.NAPCATUSER }}
  NAPCATPASS: ${{ secrets.NAPCATPASS }}
  # --- [æ–°å¢] Windows RDP & Ngrok Secrets ---
  NGROK_AUTHTOKEN: ${{ secrets.NGROK_AUTHTOKEN }}
  RDP_USER: ${{ secrets.RDP_USER }}
  RDP_PASS: ${{ secrets.RDP_PASS }}

jobs:
  build-and-run-on-windows:
    name: "Run All Services on Windows (WSL & RDP)"
    runs-on: windows-latest
    steps:
      - name: 1. æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: 2. æœ€å¤§åŒ–è¿è¡Œå™¨ç£ç›˜ç©ºé—´
        run: |
          echo "Disabling pagefile to free up space..."
          wmic pagefileset where name="C:\\pagefile.sys" delete
          echo "Removing large directories..."
          Remove-Item -Recurse -Force "C:\Program Files\dotnet"
          Remove-Item -Recurse -Force "C:\Program Files (x86)\Android"
          Remove-Item -Recurse -Force "C:\Program Files (x86)\Microsoft Visual Studio"
          Remove-Item -Recurse -Force "C:\hostedtoolcache\windows"

      - name: 3. å®‰è£…å…¨éƒ¨æ‰€éœ€ä¾èµ– (WSL, Rclone, ZSTD, JQ, Ngrok)
        run: |
          echo "Installing tools via Chocolatey..."
          choco install rclone zstd jq ngrok -y
          echo "Enabling WSL and installing Ubuntu..."
          wsl --install -d Ubuntu
          wsl --set-default-version 2

      - name: 4. âš¡ï¸ æ™ºèƒ½æ¢å¤æˆ–åˆ›å»º WSL ç¯å¢ƒ
        id: restore_or_create
        shell: pwsh
        run: |
          New-Item -Path "C:\temp" -ItemType Directory -Force
          rclone config create webdav webdav url="${{ env.WEBDAV_URL }}" vendor=other user="${{ env.WEBDAV_USER }}" pass="${{ env.WEBDAV_PASS }}"
          
          echo "1. æ­£åœ¨æŸ¥æ‰¾æœ€æ–°çš„å¤‡ä»½ (ä¼˜å…ˆ .zst, å…¶æ¬¡ .gz)..."
          $LATEST_BACKUP_FILENAME = rclone lsjson webdav:${{ env.WEBDAV_REMOTE_PATH }}/ | ConvertFrom-Json | Where-Object { $_.Name -match "minisys_wsl_backup_.*\.tar\.(zst|gz)$" } | Sort-Object -Property ModTime | Select-Object -Last 1 | Select-Object -ExpandProperty Name
          
          if ($LATEST_BACKUP_FILENAME) {
            echo "   -> âœ… å‘ç°æœ€æ–°å¯ç”¨å¤‡ä»½: $LATEST_BACKUP_FILENAME"
            $REMOTE_FILE = "webdav:${{ env.WEBDAV_REMOTE_PATH }}/${LATEST_BACKUP_FILENAME}"
            
            # ä¸‹è½½
            echo "--- âœ… å¼€å§‹ä¸‹è½½å¤‡ä»½..."
            rclone copyto $REMOTE_FILE ${{ env.LOCAL_COMPRESSED_PATH }} ${{ env.RCLONE_FLAGS }}
            
            # è§£å‹
            echo "--- âœ… ä¸‹è½½å®Œæˆã€‚å¼€å§‹è§£å‹..."
            if ($LATEST_BACKUP_FILENAME.EndsWith(".zst")) {
              echo "   -> ä½¿ç”¨ zstd è¿›è¡Œè§£å‹..."
              zstd -d -f ${{ env.LOCAL_COMPRESSED_PATH }} -o ${{ env.LOCAL_ARCHIVE_PATH }}
            } else {
              echo "   -> ä½¿ç”¨ pigz (gzip) è¿›è¡Œè§£å‹..."
              tar -xzf ${{ env.LOCAL_COMPRESSED_PATH }} -C C:\temp\
              # Find the extracted .tar file if the name is not predictable
              $ExtractedTar = Get-ChildItem -Path C:\temp -Filter *.tar | Select-Object -First 1
              Move-Item -Path $ExtractedTar.FullName -Destination ${{ env.LOCAL_ARCHIVE_PATH }}
            }

            # å¯¼å…¥ WSL
            echo "--- âœ… è§£å‹å®Œæˆã€‚æ­£åœ¨å¯¼å…¥åˆ° WSL..."
            wsl --unregister ${{ env.WSL_DISTRO_NAME }} | Out-Null # Ensure old instance is gone
            wsl --import ${{ env.WSL_DISTRO_NAME }} ${{ env.WSL_INSTALL_DIR }} ${{ env.LOCAL_ARCHIVE_PATH }}
            echo "restored=true" >> $env:GITHUB_OUTPUT
            
          } else {
            echo "--- âš ï¸ æ‰€æœ‰ç±»å‹çš„å¤‡ä»½å‡æœªæ‰¾åˆ°ã€‚å°†é‡å‘½åé»˜è®¤å®‰è£…çš„Ubuntu..."
            # The default installed Ubuntu becomes our base
            wsl --unregister ${{ env.WSL_DISTRO_NAME }} | Out-Null
            wsl --export Ubuntu C:\temp\ubuntu.tar
            wsl --import ${{ env.WSL_DISTRO_NAME }} ${{ env.WSL_INSTALL_DIR }} C:\temp\ubuntu.tar
            echo "restored=false" >> $env:GITHUB_OUTPUT
          }
          # Set the new/restored distro as default
          wsl --set-default ${{ env.WSL_DISTRO_NAME }}
          echo "--- âœ… WSL ç¯å¢ƒå‡†å¤‡å°±ç»ª ---"

      - name: 5. [å¢å¼º] æ¸…ç† WSL ç¯å¢ƒç©ºé—´
        if: steps.restore_or_create.outputs.restored == 'true'
        shell: wsl -d ${{ env.WSL_DISTRO_NAME }} -e bash -c
        run: |
          set -e
          echo "--- å¼€å§‹æ·±åº¦æ¸…ç† WSL ç¯å¢ƒ ---"
          echo '1. æ¸…ç† apt ç¼“å­˜...'
          apt-get clean -y > /dev/null 2>&1
          apt-get autoclean -y > /dev/null 2>&1
          apt-get autoremove -y > /dev/null 2>&1
          rm -rf /var/lib/apt/lists/*
          
          echo '2. æ¸…ç†é€šç”¨ä¸´æ—¶æ–‡ä»¶å’Œæ—¥å¿—...'
          rm -rf /tmp/* /var/tmp/*
          find /var/log -type f -name '*.log' -delete
          find /var/log -type f -name '*.gz' -delete
          
          echo '3. æ¸…ç†ç”¨æˆ·ç¼“å­˜å’Œå†å²è®°å½•...'
          rm -rf /root/.cache /root/.npm /root/.bash_history
          
          echo 'âœ… WSL ç¯å¢ƒæ¸…ç†å®Œæˆã€‚'

      - name: 6A. [è‡ªåŠ¨åŒ–è·¯å¾„] æ ¹æ®å¼€å…³å¯åŠ¨æœåŠ¡å¹¶åŠ¨æ€æš‚åœ
        if: >
          github.event.inputs.run_startup_script == 'true' &&
          github.event.inputs.enable_rdp_access == 'false'
        shell: pwsh
        run: |
          $RUNTIME_MINUTES = if ('${{ github.event.inputs.create_backup_on_finish }}' -eq 'true') { 300 } else { 350 }
          echo "âœ… è¿›å…¥è‡ªåŠ¨åŒ–è¿è¡Œæ¨¡å¼ (WSL æœåŠ¡)..."
          
          # Create the startup script using PowerShell Here-String
          $ScriptContent = @"
          #!/bin/bash
          set -e
          # --- åŠ¨æ€ä¼ å…¥æ‰€æœ‰å¼€å…³å’Œé…ç½® (ä¿®æ­£ï¼šä¸º schedule ä»»åŠ¡æä¾›é»˜è®¤å€¼ 'true') ---
          export RUN_LAUNCHER='${{ github.event.inputs.run_launcher || (github.event_name == 'schedule' && 'true') }}'
          export RUN_REDIS='${{ github.event.inputs.run_redis || (github.event_name == 'schedule' && 'true') }}'
          export RUN_YUNZAI='${{ github.event.inputs.run_yunzai || (github.event_name == 'schedule' && 'true') }}'
          export RUN_LOOPHOLE_WEBDAV='${{ github.event.inputs.run_loophole_webdav || (github.event_name == 'schedule' && 'true') }}'
          export RUN_OPENLIST='${{ github.event.inputs.run_openlist || (github.event_name == 'schedule' && 'true') }}'
          export RUN_CHMLFRP='${{ github.event.inputs.run_chmlfrp || (github.event_name == 'schedule' && 'true') }}'
          export ENABLE_NAPCAT_TUNNEL='${{ github.event.inputs.enable_napcat_tunnel || 'false' }}'

          export LOOPHOLE_WEBDAV_USER='${{ env.LOOPHOLE_WEBDAV_USER }}'
          export LOOPHOLE_WEBDAV_PASS='${{ env.LOOPHOLE_WEBDAV_PASS }}'
          export LOOPHOLE_WEBDAV_HOSTNAME='${{ env.LOOPHOLE_WEBDAV_HOSTNAME }}'
          export LOOPHOLE_NAPCAT_HOSTNAME='${{ env.LOOPHOLE_NAPCAT_HOSTNAME }}'
          export NAPCATUSER='${{ env.NAPCATUSER }}'
          export NAPCATPASS='${{ env.NAPCATPASS }}'
          export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/root/node_modules/.bin
          HOME_DIR="/root"

          echo "--- [WSL ç¯å¢ƒå†…] å¼€å§‹æ‰§è¡Œè‡ªåŠ¨åŒ–å¯åŠ¨ä»»åŠ¡ ---"
          if ! command -v pm2 &> /dev/null; then npm install -g pm2; fi
          echo "1. æ¸…ç†æ—§æ—¥å¿—..." && pm2 flush && find \${HOME_DIR} -name "*.log" -type f -delete
          
          if [[ "\$RUN_LAUNCHER" == "true" ]]; then echo "2. å¯åŠ¨ launcher..."; [ -f "\${HOME_DIR}/launcher.sh" ] && (cd "\${HOME_DIR}" && pm2 start ./launcher.sh --name "launcher" --output /dev/null --error /dev/null || pm2 restart "launcher") || echo "  -> è­¦å‘Š: launcher.sh æœªæ‰¾åˆ°ã€‚"; else echo "2. [å·²ç¦ç”¨] è·³è¿‡ launcherã€‚"; fi
          if [[ "\$RUN_REDIS" == "true" ]]; then echo "3. å¯åŠ¨ Redis..."; command -v redis-server &> /dev/null && redis-server --daemonize yes || echo "  -> è­¦å‘Š: redis-server æœªæ‰¾åˆ°ã€‚"; else echo "3. [å·²ç¦ç”¨] è·³è¿‡ Redisã€‚"; fi
          if [[ "\$RUN_YUNZAI" == "true" ]]; then echo "4. å¯åŠ¨ Yunzai-Bot..."; [ -d "\${HOME_DIR}/Yunzai" ] && (cd "\${HOME_DIR}/Yunzai" && pm2 start app.js --name "yunzai-app" || pm2 restart "yunzai-app") || echo "  -> è­¦å‘Š: Yunzai ç›®å½•æœªæ‰¾åˆ°ã€‚"; else echo "4. [å·²ç¦ç”¨] è·³è¿‡ Yunzai-Botã€‚"; fi
          if [[ "\$RUN_LOOPHOLE_WEBDAV" == "true" ]]; then echo "5. å¯åŠ¨ loophole..."; if [ -f "\${HOME_DIR}/loophole/loophole" ]; then cd "\${HOME_DIR}/loophole"; pm2 start ./loophole --name "loophole-webdav" -- webdav ~ -u "\${LOOPHOLE_WEBDAV_USER}" -p "\${LOOPHOLE_WEBDAV_PASS}" --hostname "\${LOOPHOLE_WEBDAV_HOSTNAME}"; if [[ "\$ENABLE_NAPCAT_TUNNEL" == "true" ]]; then echo "  -> å¯ç”¨ Napcat éš§é“..."; pm2 start ./loophole --name "loophole-http" -- http 6099 --hostname "${LOOPHOLE_NAPCAT_HOSTNAME}" --basic-auth-username "${NAPCATUSER}" --basic-auth-password "${NAPCATPASS}"; fi; else echo "  -> è­¦å‘Š: loophole æœªæ‰¾åˆ°ã€‚"; fi; else echo "5. [å·²ç¦ç”¨] è·³è¿‡ loopholeã€‚"; fi
          if [[ "\$RUN_OPENLIST" == "true" ]]; then echo "6. å¯åŠ¨ openlist..."; [ -f "\${HOME_DIR}/openlist" ] && (cd "\${HOME_DIR}" && pm2 start ./openlist --name "openlist-server" -- server) || echo "  -> è­¦å‘Š: openlist æœªæ‰¾åˆ°ã€‚"; else echo "6. [å·²ç¦ç”¨] è·³è¿‡ openlistã€‚"; fi
          if [[ "\$RUN_CHMLFRP" == "true" ]]; then echo "7. å¯åŠ¨ ChmlFrp..."; [ -f "\${HOME_DIR}/ChmlFrp/frpc" ] && (cd "\${HOME_DIR}/ChmlFrp" && pm2 start ./frpc --name "chml-frp" -- -c frpc.ini) || echo "  -> è­¦å‘Š: frpc æœªæ‰¾åˆ°ã€‚"; else echo "7. [å·²ç¦ç”¨] è·³è¿‡ ChmlFrpã€‚"; fi

          echo "--- [WSL ç¯å¢ƒå†…] ä»»åŠ¡æ´¾å‘å®Œæˆï¼Œä¿å­˜PM2è¿›ç¨‹åˆ—è¡¨ ---"
          pm2 save && pm2 ls
"@
          # Execute the script inside WSL
          wsl -d ${{ env.WSL_DISTRO_NAME }} -e bash -c $ScriptContent

          echo "ğŸš€ æœåŠ¡å·²æ ¹æ®å¼€å…³å¯åŠ¨ã€‚å·¥ä½œæµå°†æš‚åœ ${RUNTIME_MINUTES} åˆ†é’Ÿ (å¤‡ä»½è®¾ç½®: ${{ github.event.inputs.create_backup_on_finish }}) ..."
          Start-Sleep -Seconds ($RUNTIME_MINUTES * 60)
          echo "â³ è§„å®šè¿è¡Œæ—¶é—´å·²åˆ°ã€‚"

      - name: 6B. [æ‰‹åŠ¨è°ƒè¯•è·¯å¾„] å¯ç”¨ RDP å’Œ Ngrok éš§é“
        if: github.event.inputs.enable_rdp_access == 'true'
        shell: pwsh
        run: |
          echo "æ­£åœ¨ä¸º RDP è®¿é—®é…ç½® Windows..."
          # ä¸º RDP è®¾ç½®é˜²ç«å¢™è§„åˆ™
          netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
          # åˆ›å»º RDP ç”¨æˆ·å¹¶æ·»åŠ åˆ°ç”¨æˆ·ç»„
          net user ${{ env.RDP_USER }} "${{ env.RDP_PASS }}" /add
          net localgroup "Remote Desktop Users" ${{ env.RDP_USER }} /add
          
          echo "================================================================"
          echo "âœ… RDP é…ç½®å®Œæˆ"
          echo "  Windows ç”¨æˆ·å: ${{ env.RDP_USER }}"
          echo "  Windows å¯†ç :   ${{ env.RDP_PASS }}"
          echo "  è¯·ä½¿ç”¨ä¸‹æ–¹çš„ Ngrok åœ°å€é€šè¿‡ RDP å®¢æˆ·ç«¯è¿æ¥"
          echo "================================================================"
          
          # å¯åŠ¨ Ngrok éš§é“
          ngrok config add-authtoken ${{ env.NGROK_AUTHTOKEN }}
          Start-Process -FilePath "ngrok.exe" -ArgumentList "tcp 3389" -NoNewWindow
          
          # ç­‰å¾…ï¼Œè®©ç”¨æˆ·æœ‰æ—¶é—´è¿æ¥
          echo "â³ å·¥ä½œæµå°†æš‚åœ 350 åˆ†é’Ÿä»¥ä¾›æ‰‹åŠ¨è°ƒè¯•ã€‚è¯·ä»ä¸Šæ–¹çš„ ngrok æ—¥å¿—ä¸­æŸ¥æ‰¾è¿æ¥åœ°å€ã€‚"
          Start-Sleep -Seconds 21000

      - name: 7. âš¡ï¸ [æé€Ÿ] åˆ›å»ºç‰ˆæœ¬åŒ–å¤‡ä»½ (WSL Export & zstd) å¹¶æ¸…ç†æ—§ç‰ˆæœ¬
        if: success() && !cancelled() && github.event.inputs.create_backup_on_finish == 'true'
        shell: pwsh
        run: |
          echo "--- 1. åœæ­¢ WSL å†…æœåŠ¡å¹¶å¯¼å‡ºæ•´ä¸ª WSL å‘è¡Œç‰ˆ ---"
          wsl -d ${{ env.WSL_DISTRO_NAME }} -e bash -c "command -v pm2 && pm2 stop all"
          wsl --shutdown
          Start-Sleep -Seconds 5 # Give time for shutdown
          wsl --export ${{ env.WSL_DISTRO_NAME }} ${{ env.LOCAL_ARCHIVE_PATH }}
          
          echo "--- 2. ä½¿ç”¨ zstd (é«˜å‹ç¼©ç­‰çº§) åˆ›å»ºæ–°çš„é«˜é€Ÿå¤‡ä»½ ---"
          $TIMESTAMP = Get-Date -UFormat '%Y%m%d-%H%M%S'
          $NEW_BACKUP_FILE = "${{ env.BACKUP_PREFIX }}${TIMESTAMP}.tar.zst"
          echo "æ–°å¤‡ä»½æ–‡ä»¶å: $NEW_BACKUP_FILE"
          zstd -T0 -15 -f ${{ env.LOCAL_ARCHIVE_PATH }} -o ${{ env.LOCAL_COMPRESSED_PATH }}
          
          echo "--- 3. ä¸Šä¼ æ–°å¤‡ä»½ ---"
          rclone rcat webdav:${{ env.WEBDAV_REMOTE_PATH }}/$NEW_BACKUP_FILE - < ${{ env.LOCAL_COMPRESSED_PATH }}
          echo "âœ… æ–°å¤‡ä»½ä¸Šä¼ æˆåŠŸã€‚"

          echo "--- 4. æ¸…ç†æ—§å¤‡ä»½ (ä¿ç•™3ä¸ªæœ€æ–°, å…¼å®¹ gz/zst) ---"
          $FILES_TO_DELETE = rclone lsjson webdav:${{ env.WEBDAV_REMOTE_PATH }}/ | ConvertFrom-Json | Where-Object { $_.Name -match "minisys_wsl_backup_.*\.tar\.(zst|gz)$" } | Sort-Object -Property ModTime | Select-Object -First ([System.Math]::Max(0, (rclone lsjson webdav:${{ env.WEBDAV_REMOTE_PATH }}/ | ConvertFrom-Json).Count - 3)) | Select-Object -ExpandProperty Name
          
          if ($FILES_TO_DELETE) {
            echo "å°†è¦åˆ é™¤ä»¥ä¸‹æ—§å¤‡ä»½:"
            $FILES_TO_DELETE | ForEach-Object { Write-Host $_ }
            foreach ($file_name in $FILES_TO_DELETE) {
              $FULL_REMOTE_PATH = "${{ env.WEBDAV_REMOTE_PATH }}/${file_name}"
              echo "Deleting: $FULL_REMOTE_PATH"
              rclone deletefile "webdav:${FULL_REMOTE_PATH}"
            }
            echo "âœ… æ—§å¤‡ä»½æ¸…ç†å®Œæ¯•ã€‚"
          } else {
            echo "æ— éœ€æ¸…ç†ï¼Œå¤‡ä»½æ•°é‡å°äºæˆ–ç­‰äº3ã€‚"
          }
          
      - name: 8. æ¸…ç†è¿è¡Œå™¨ç¯å¢ƒ
        if: always()
        shell: pwsh
        run: |
          echo "--- å¼€å§‹æ¸…ç†è¿è¡Œå™¨ç¯å¢ƒ ---"
          # åœæ­¢å¹¶æ³¨é”€ WSL å®ä¾‹ä»¥é‡Šæ”¾æ‰€æœ‰èµ„æº
          wsl --terminate ${{ env.WSL_DISTRO_NAME }} | Out-Null
          wsl --unregister ${{ env.WSL_DISTRO_NAME }} | Out-Null
          # æ¸…ç†ä¸´æ—¶æ–‡ä»¶å’Œç›®å½•
          Remove-Item -Recurse -Force ${{ env.WSL_INSTALL_DIR }} -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "C:\temp" -ErrorAction SilentlyContinue
          choco uninstall rclone zstd jq ngrok -y
          echo "âœ… è¿è¡Œå™¨æ¸…ç†å®Œæˆã€‚"